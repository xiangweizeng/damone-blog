import{_ as t,N as n,S as e,Z as l,U as s,a0 as a}from"./framework-72158890.js";const m="/damone-blog/images/datastruct/20160714130435508.png",i="/damone-blog/images/datastruct/1638175026761.png",o="/damone-blog/images/datastruct/1638175026757.png",r={},c=l('<h1 id="_5-5-最小生成树" tabindex="-1"><a class="header-anchor" href="#_5-5-最小生成树" aria-hidden="true">#</a> 5.5 最小生成树</h1><h2 id="_5-5-1-最小生成树的概念" tabindex="-1"><a class="header-anchor" href="#_5-5-1-最小生成树的概念" aria-hidden="true">#</a> 5.5.1 最小生成树的概念</h2><p>连通图生成树，非连通图生成森林</p><p><code>生成树</code>是包含图中全部顶点的一个<code>极小连通子图</code><code>特性</code>：图中有n个顶点，则它的生成树含有n-1条边。 去除一条边会变成非连通图；加上一条边会变成一个回路</p><p>之前学过<code>广度优先生成树</code>和<code>深度优先生成树</code>。</p><p><code>最小生成树</code>，也叫<code>最小代价树</code>。在带权连通无向图的所有生成树中，所有边的代价和最小。</p><p>最小生成树可能很多，但边的权值之和总是唯一且最小的。</p><p><code>最小生成的边=顶点数-1</code></p><figure><img src="'+m+'" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><h2 id="_5-5-2-prim算法-普利姆算法" tabindex="-1"><a class="header-anchor" href="#_5-5-2-prim算法-普利姆算法" aria-hidden="true">#</a> 5.5.2 Prim算法（普利姆算法）</h2><p>此算法可以称为<code>“加点法”</code>，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p>实现思想：以最低代价加入<code>点</code>。 用两个数组：</p><ul><li>①<code>isJoin数组</code>：标记<code>各结点</code>是否已加入树。</li><li>②<code>lowCost数组</code>：各节点加入树的最低代价。</li></ul>',13),p=s("p",null,[a("每轮遍历"),s("strong",null,"isJoin"),a("数组，第一遍找到"),s("strong",null,"lowCost"),a("最低的顶点，然后加入；第二遍循环遍历更新各点的"),s("strong",null,"lowCost"),a("值。 则"),s("code",null,"时间复杂度"),a("="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"V"),s("msup",null,[s("mi",{mathvariant:"normal"},"∣"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(|V|^2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),s("span",{class:"mord"},[s("span",{class:"mord"},"∣"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mclose"},")")])])]),a("，适合"),s("code",null,"边稠密图")],-1),h=l('<figure><img src="'+i+'" alt="1638175026761" tabindex="0" loading="lazy"><figcaption>1638175026761</figcaption></figure><figure><img src="'+o+'" alt="1638175026757" tabindex="0" loading="lazy"><figcaption>1638175026757</figcaption></figure><h3 id="_5-5-3-kruskal算法-克鲁斯卡尔算法" tabindex="-1"><a class="header-anchor" href="#_5-5-3-kruskal算法-克鲁斯卡尔算法" aria-hidden="true">#</a> 5.5.3 Kruskal算法（克鲁斯卡尔算法）</h3><p>此算法可以称为<code>“加边法”</code>，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p><p>实现思想：以最低代价加入<code>边</code>。 用一个表： （weight（边权），Vertex1（点1），Vertex2（点2）） 用<code>并查集</code>检查下一个边的两个点是否已连接。</p>',5),d=s("p",null,[a("判断两个点是否已连接需要"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"l"),s("mi",null,"o"),s("msub",null,[s("mi",null,"g"),s("mn",null,"2")]),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(log_2|E|)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"o"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord"},"∣"),s("span",{class:"mclose"},")")])])]),a("，工执行e轮。 则"),s("code",null,"时间复杂度"),a("="),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"l"),s("mi",null,"o"),s("msub",null,[s("mi",null,"g"),s("mn",null,"2")]),s("mi",{mathvariant:"normal"},"∣"),s("mi",null,"E"),s("mi",{mathvariant:"normal"},"∣"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(|E|log_2|E|)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"o"),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3011em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mord"},"∣"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mord"},"∣"),s("span",{class:"mclose"},")")])])]),a("，适合"),s("code",null,"边稀疏图")],-1),g=[c,p,h,d];function u(_,y){return n(),e("div",null,g)}const x=t(r,[["render",u],["__file","5.5最小生成树.html.vue"]]);export{x as default};
