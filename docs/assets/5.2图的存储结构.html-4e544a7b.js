import{_ as t}from"./1637934445539-03acef5d.js";import{_ as e,N as l,S as c,Z as n,U as a,a0 as s}from"./framework-72158890.js";const i="/damone-blog/images/datastruct/1637936258196.png",o="/damone-blog/images/datastruct/1637846244394.png",p="/damone-blog/images/datastruct/1637848061168.png",m="/damone-blog/images/datastruct/1637936499284.png",r="/damone-blog/images/datastruct/1637936777739.png",d={},u=n('<h1 id="_5-2-图的存储结构" tabindex="-1"><a class="header-anchor" href="#_5-2-图的存储结构" aria-hidden="true">#</a> 5.2 图的存储结构</h1><h2 id="_5-2-1-图的存储结构" tabindex="-1"><a class="header-anchor" href="#_5-2-1-图的存储结构" aria-hidden="true">#</a> 5.2.1 图的存储结构</h2><ul><li>①领接矩阵：顺序存储（一维数组存点的数据，二维数组存边的连接情况）(存储无向图、有向图)</li><li>②邻接表：顺序+链式存储（顺序存点的数据，链存连接该点的边）（存储有向图、无向图）</li><li>③十字链表：链式存储（存储有向图）</li><li>④邻接多重表：链式存储（存储无向图）</li></ul><figure><img src="'+i+'" alt="1637936258196" tabindex="0" loading="lazy"><figcaption>1637936258196</figcaption></figure><h2 id="_5-2-2-邻接矩阵法" tabindex="-1"><a class="header-anchor" href="#_5-2-2-邻接矩阵法" aria-hidden="true">#</a> 5.2.2 邻接矩阵法</h2>',5),h=a("p",null,[a("code",null,"空间复杂度"),s("="),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("msup",null,[a("mi",{mathvariant:"normal"},"∣"),a("mn",null,"2")])]),a("annotation",{encoding:"application/x-tex"},"O(|V|^2")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},[a("span",{class:"mord"},"∣"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.8141em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mtight"},"2")])])])])])])])])])]),s("，"),a("code",null,"适合存稠密图")],-1),g=a("p",null,[a("code",null,"无向图的邻接矩阵"),s("是"),a("code",null,"对称矩阵"),s("，可以"),a("code",null,"压缩存储"),s("，见3.6")],-1),k=a("p",null,[a("code",null,"性质"),s("："),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"A")]),a("annotation",{encoding:"application/x-tex"},"A")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"A")])])]),s("为图"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"G")]),a("annotation",{encoding:"application/x-tex"},"G")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"G")])])]),s("的邻接矩阵，则"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("msup",null,[a("mi",null,"A"),a("mi",null,"n")])]),a("annotation",{encoding:"application/x-tex"},"A^n")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord"},[a("span",{class:"mord mathnormal"},"A"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.6644em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),s("的元素"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("msup",null,[a("mi",null,"A"),a("mi",null,"n")]),a("mo",{stretchy:"false"},"["),a("mi",null,"i"),a("mo",{stretchy:"false"},"]"),a("mo",{stretchy:"false"},"["),a("mi",null,"j"),a("mo",{stretchy:"false"},"]")]),a("annotation",{encoding:"application/x-tex"},"A^n[i][j]")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},[a("span",{class:"mord mathnormal"},"A"),a("span",{class:"msupsub"},[a("span",{class:"vlist-t"},[a("span",{class:"vlist-r"},[a("span",{class:"vlist",style:{height:"0.6644em"}},[a("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{class:"pstrut",style:{height:"2.7em"}}),a("span",{class:"sizing reset-size6 size3 mtight"},[a("span",{class:"mord mathnormal mtight"},"n")])])])])])])]),a("span",{class:"mopen"},"["),a("span",{class:"mord mathnormal"},"i"),a("span",{class:"mclose"},"]"),a("span",{class:"mopen"},"["),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j"),a("span",{class:"mclose"},"]")])])]),s("="),a("code",null,"顶点i到顶点j的长度为n的路径的数目")],-1),v=n('<p><code>计算度、入度、出度</code>：必须遍历对应的行或列。 <code>找相邻的边</code>：必须遍历对应的行或列。</p><h3 id="普通图的领接矩阵法" tabindex="-1"><a class="header-anchor" href="#普通图的领接矩阵法" aria-hidden="true">#</a> 普通图的领接矩阵法：</h3><figure><img src="'+o+`" alt="1637846244394" tabindex="0" loading="lazy"><figcaption>1637846244394</figcaption></figure><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxVertexNum</span> <span class="token expression"><span class="token number">100</span>                 </span><span class="token comment">//顶点数目最大值</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> Vex<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">//顶点表：存每个点的数据</span>
    <span class="token keyword">int</span> Edge<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//邻接矩阵，边表：存边的连接情况</span>
    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span> arcnum<span class="token punctuation">;</span>                  <span class="token comment">//图当前的顶点数和边数（弧数）</span>
<span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>边可以是int，bool或枚举型变量。</p><h3 id="普通图的度、入度、出度" tabindex="-1"><a class="header-anchor" href="#普通图的度、入度、出度" aria-hidden="true">#</a> 普通图的度、入度、出度</h3><p>某点的度：某点的边数</p><p>无向图： <code>第i个结点的度</code>=<code>第i行(第i列)</code>的<code>非零元素</code>个数。</p><p>有向图： <code>第i个结点的出度</code>=<code>第i行</code>的<code>非零元素</code>个数。 <code>第i个结点的入度</code>=<code>第i列</code>的<code>非零元素</code>个数。 <code>第i个结点的度</code>=<code>第i行、第i列</code>的<code>非零元素</code>个数<code>之和</code>。</p>`,9),x=a("p",null,[s("求顶点的度、入度、出度的"),a("code",null,"时间复杂度"),s("=O("),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣")]),a("annotation",{encoding:"application/x-tex"},"|V|")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣")])])]),s(")")],-1),y=n('<h3 id="带权图的领接矩阵法" tabindex="-1"><a class="header-anchor" href="#带权图的领接矩阵法" aria-hidden="true">#</a> 带权图的领接矩阵法</h3><figure><img src="'+p+`" alt="1637848061168" tabindex="0" loading="lazy"><figcaption>1637848061168</figcaption></figure><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxVertexNum</span> <span class="token expression"><span class="token number">100</span>                 </span><span class="token comment">//顶点数目最大值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFINITY</span> <span class="token expression"><span class="token number">4294967295</span>              </span><span class="token comment">//宏定义常量“无穷”，4294967295为最大的int值</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexType<span class="token punctuation">;</span>                 <span class="token comment">//顶点的数据类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> EdgeType<span class="token punctuation">;</span>                    <span class="token comment">//边的数据类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    VertexType Vex<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//顶点表：存每个点的数据</span>
    EdgeType Edge<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//邻接矩阵，边表：存边的连接情况</span>
    <span class="token keyword">int</span> vexnum<span class="token punctuation">,</span> arcnum<span class="token punctuation">;</span>                  <span class="token comment">//图当前的顶点数和边数（弧数）</span>
<span class="token punctuation">}</span>MGraph<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-2-3-邻接表法" tabindex="-1"><a class="header-anchor" href="#_5-2-3-邻接表法" aria-hidden="true">#</a> 5.2.3 邻接表法</h2>`,4),b=a("p",null,[a("code",null,"空间复杂度"),s("：无向图为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣"),a("mo",null,"+"),a("mn",null,"2"),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"E"),a("mi",{mathvariant:"normal"},"∣"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(|V|+2|E|)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"2∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),a("span",{class:"mord"},"∣"),a("span",{class:"mclose"},")")])])]),s("，有向图为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣"),a("mo",null,"+"),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"E"),a("mi",{mathvariant:"normal"},"∣"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(|V|+|E|)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),a("span",{class:"mord"},"∣"),a("span",{class:"mclose"},")")])])]),s("，"),a("code",null,"适合存稀疏图"),a("code",null,"表示方式不唯一")],-1),_=n('<p>邻接矩阵降低了空间复杂度，但使操作不方便了： <code>计算度、入度、出度</code>：计算有向图的度、入度不方便，其余很方便。</p><p><code>找相邻的边</code>：找有向图的入边不方便。</p><h3 id="图的类型描述" tabindex="-1"><a class="header-anchor" href="#图的类型描述" aria-hidden="true">#</a> 图的类型描述：</h3><p>与树的孩子表示法很像</p><figure><img src="'+t+`" alt="1637934445539" tabindex="0" loading="lazy"><figcaption>1637934445539</figcaption></figure><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxVertexNum</span> <span class="token expression"><span class="token number">100</span>       </span><span class="token comment">//顶点数目最大值</span></span>
<span class="token comment">//&quot;边（弧）&quot;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>                <span class="token comment">//边（弧）指向那个结点</span>
    <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>      <span class="token comment">//指向下一条弧的指针</span>
    <span class="token comment">//InfoType info;           //边权值</span>
<span class="token punctuation">}</span>ArcNode<span class="token punctuation">;</span>
<span class="token comment">//&quot;顶点&quot;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VNode</span><span class="token punctuation">{</span>
    VertexType data<span class="token punctuation">;</span>           <span class="token comment">//顶点数据</span>
    ArcNode <span class="token operator">*</span>first<span class="token punctuation">;</span>            <span class="token comment">//顶点指向的第一条边</span>
<span class="token punctuation">}</span>VNode<span class="token punctuation">,</span> AdjList<span class="token punctuation">[</span>MaxVertexNum<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//用领接表存储图</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    AdjList vertices<span class="token punctuation">;</span>          <span class="token comment">//顶点数组</span>
    <span class="token keyword">int</span> vernum<span class="token punctuation">,</span> arcnum<span class="token punctuation">;</span>        <span class="token comment">////图当前的顶点数和边数（弧数）</span>
<span class="token punctuation">}</span>ALGraph<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-2-4-十字链表法" tabindex="-1"><a class="header-anchor" href="#_5-2-4-十字链表法" aria-hidden="true">#</a> 5.2.4 十字链表法</h2>`,7),w=a("p",null,[a("code",null,"空间复杂度"),s("："),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣"),a("mo",null,"+"),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"E"),a("mi",{mathvariant:"normal"},"∣"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(|V|+|E|)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),a("span",{class:"mord"},"∣"),a("span",{class:"mclose"},")")])])]),s("，与邻接表法一样")],-1),f=a("p",null,"解决了邻接表法的找入边难的问题。",-1),M=a("figure",null,[a("img",{src:m,alt:"1637936499284",tabindex:"0",loading:"lazy"}),a("figcaption",null,"1637936499284")],-1),V=a("h2",{id:"_5-2-5-邻接多重表",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_5-2-5-邻接多重表","aria-hidden":"true"},"#"),s(" 5.2.5 邻接多重表")],-1),N=a("p",null,[a("code",null,"空间复杂度"),s("："),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣"),a("mo",null,"+"),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"E"),a("mi",{mathvariant:"normal"},"∣"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(|V|+|E|)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),a("span",{class:"mord"},"∣"),a("span",{class:"mclose"},")")])])]),s("，比邻接表法的"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"V"),a("mi",{mathvariant:"normal"},"∣"),a("mo",null,"+"),a("mn",null,"2"),a("mi",{mathvariant:"normal"},"∣"),a("mi",null,"E"),a("mi",{mathvariant:"normal"},"∣"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(|V|+2|E|)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord"},"∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),a("span",{class:"mord"},"∣"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"+"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord"},"2∣"),a("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),a("span",{class:"mord"},"∣"),a("span",{class:"mclose"},")")])])]),s("好")],-1),E=a("p",null,"解决了邻接表法存两遍边的空间浪费。",-1),O=a("p",null,"删除边、删除结点等操作很方便。",-1),A=a("figure",null,[a("img",{src:r,alt:"1637936777739",tabindex:"0",loading:"lazy"}),a("figcaption",null,"1637936777739")],-1),z=[u,h,g,k,v,x,y,b,_,w,f,M,V,N,E,O,A];function L(T,j){return l(),c("div",null,z)}const I=e(d,[["render",L],["__file","5.2图的存储结构.html.vue"]]);export{I as default};
