export const pagesRoutes = [
  ["v-8daa1a0e","/",{"y":"h","t":"主页","i":"material-symbols:home-outline-rounded"},["/index.html","/README.md"]],
  ["v-74bc627b","/about/",{"y":"h","t":"个人简介","i":"mdi:about-circle-outline","I":0},["/about/index.html","/about/README.md"]],
  ["v-145ac574","/blog/",{"y":"p","t":"工作总结","i":"ic:outline-maps-home-work","I":0},["/blog/index.html","/blog/README.md"]],
  ["v-6c575b87","/collect-data/development.html",{"c":["收藏总结","算法及数据结构","操作系统","设计模式","程序打包及安装","测试"],"e":"<h2> 算法及数据结构</h2>\n<ol>\n<li><a href=\"https://blog.csdn.net/Holmofy/article/details/71168530\" target=\"_blank\" rel=\"noopener noreferrer\">单轴快排（SinglePivotQuickSort）和双轴快排（DualPivotQuickSort）及其 JAVA 实现</a></li>\n<li>数据结构总结</li>\n</ol>\n<iframe src=\"https://www.processon.com/embed/5ce9eb3de4b0d7395a15f36d\" width=\"100%\" height=\"500\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\">\n </iframe>","y":"a","t":"程序开发","i":"carbon:development","O":1},["/collect-data/development","/collect-data/development.md"]],
  ["v-69bd28b7","/collect-data/distributed-system.html",{"c":["收藏总结","WEB 服务器","数据库","高性能高并发","分布式原理","数据分析","数据存储","容器及虚拟化技术","消息中间件","离线批处理","综合解决方案","微服务架构"],"e":"<h2> WEB 服务器相关</h2>\n<ol>\n<li><a href=\"http://www.nginx.cn/doc/\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 中文文档</a></li>\n<li><a href=\"https://www.phpfans.net/manu/Squid/\" target=\"_blank\" rel=\"noopener noreferrer\">Squid中文权威指南</a></li>\n<li><a href=\"https://imququ.com/post/web-proxy.html\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP 代理原理及实现</a></li>\n<li><a href=\"https://blog.csdn.net/u012796139/article/details/50067951\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 正向代理配置</a></li>\n<li><a href=\"http://tengine.taobao.org/book/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx开发从入门到精通</a></li>\n</ol>","y":"a","t":"分布式开发","i":"fluent:align-distribute-bottom-16-filled","O":3},["/collect-data/distributed-system","/collect-data/distributed-system.md"]],
  ["v-b805d384","/collect-data/dnn.html",{"c":["收藏总结","机器视觉","深度学习"],"e":"<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/dlclass\" target=\"_blank\" rel=\"noopener noreferrer\">知乎深度学习大讲堂</a></li>\n<li><a href=\"https://github.com/RatulGhosh/awesome-machine-learning\" target=\"_blank\" rel=\"noopener noreferrer\">国外知名大学机器学习课程汇总</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/c_159931745\" target=\"_blank\" rel=\"noopener noreferrer\">深度学习论文阅读</a></li>\n<li><a href=\"https://github.com/Ewenwan/MVision\" target=\"_blank\" rel=\"noopener noreferrer\">机器人视觉资源综合</a></li>\n<li><a href=\"https://github.com/apachecn/ai-roadmap/tree/master/v1.0\" target=\"_blank\" rel=\"noopener noreferrer\">ApacheCN 人工智能知识树</a></li>\n<li><a href=\"https://www.infoq.cn/article/LjmbcEgqZV6dzXlFRsjf\" target=\"_blank\" rel=\"noopener noreferrer\">人工智能的下一个拐点：图神经网络迎来快速爆发期</a></li>\n<li><a href=\"https://blog.csdn.net/xbinworld/category_878118_1.html\" target=\"_blank\" rel=\"noopener noreferrer\">CSDN 机器学习 Machine Learning</a></li>\n<li><a href=\"https://www.zybuluo.com/vivounicorn/note/446479\" target=\"_blank\" rel=\"noopener noreferrer\">机器学习与人工智能技术分享</a></li>\n<li><a href=\"https://github.com/xiangweizeng/Mathematics\" target=\"_blank\" rel=\"noopener noreferrer\">数学知识点滴积累  矩阵 数值优化 神经网络反向传播 图优化 概率论 随机过程 卡尔曼滤波 粒子滤波</a></li>\n</ol>","y":"a","t":"深度学习及机器视觉","i":"fluent-mdl2:machine-learning","O":2},["/collect-data/dnn","/collect-data/dnn.md"]],
  ["v-e592dcdc","/collect-data/other.html",{"c":["收藏总结","金融期货","电动汽车","地图及GPS","综合及学习"],"e":"<h2> 金融期货</h2>\n<ol>\n<li><a href=\"http://www.ftchinese.com/story/001003210?archive\" target=\"_blank\" rel=\"noopener noreferrer\">市价触发单</a></li>\n<li><a href=\"https://blog.csdn.net/songzhang/article/details/1805238\" target=\"_blank\" rel=\"noopener noreferrer\">金融信息交换协议（FIX）</a></li>\n<li><a href=\"https://www.nanhua.net/x3/\" target=\"_blank\" rel=\"noopener noreferrer\">南华推手</a></li>\n<li><a href=\"https://www.onixs.biz/cpp-fix-engine.html\" target=\"_blank\" rel=\"noopener noreferrer\">OnixS C++ FIX Engine</a></li>\n<li><a href=\"https://mdemo.cqg.com/cqg/desktop/demorequest\" target=\"_blank\" rel=\"noopener noreferrer\">ＣＱＧ交易平台</a></li>\n<li><a href=\"https://www.fix8.org/downloads.html\" target=\"_blank\" rel=\"noopener noreferrer\">Ｆix8 高性能Fix库</a></li>\n<li>期货交易系统核心功能\n<img src=\"/images/collect-data/期货交易系统核心功能.png\" alt=\"期货核心交易系统\" loading=\"lazy\"></li>\n</ol>","y":"a","t":"其它","i":"material-symbols:other-admission-outline-rounded","O":4},["/collect-data/other","/collect-data/other.md"]],
  ["v-871e45ee","/collect-data/",{"y":"p","t":"收藏总结","i":"mdi:collection","I":0},["/collect-data/index.html","/collect-data/README.md"]],
  ["v-cad07a38","/computer-science/",{"y":"p","t":"计算机基础","i":"mdi:computer-classic","I":0},["/computer-science/index.html","/computer-science/README.md"]],
  ["v-01e0e76e","/blog/dnn/pub-01.html",{"c":["工作总结","客流统计","高效能加速","深度学习"],"e":"<p>客流统计系统是用机器代替人工，对公交车每个站点和每条线路的上、下车辆的人数进行实时的自动统计，同时将数据发送到后端的系统管理平台进行存储，分析数据并形成数据报表。由此，监控中心能即时了解到每辆车的载客状况、各站点的拥挤程度等数据。利用这些数据可以优化公交线路、分析与预测公交客流的实时动态、决策和调控公交的调度，在使城市交通更加智能化的同时也为城市建设规划更加人性化、民众出行更便利做出贡献。</p>\n<h2> 1 平台总体框架</h2>\n<p>如图 1 所示，客流统计平台由四个部分组成，包括升级管理平台、客流统计数据平台、终端升级管理程序及客流统计程序。下面简要介绍数据汇总平台及升级管理平台，最后重点介绍客流统计终端相关技术及实现方案。</p>","y":"a","t":"基于深度学习的公交客流统计解决方案简介"},["/blog/dnn/pub-01","/blog/dnn/pub-01.md"]],
  ["v-00c464e8","/blog/dnn/pub-02.html",{"c":["工作总结","Darknet","NCNN","深度学习"],"e":"<p>darknet2ncnn 将 darknet 模型转换为 ncnn 模型，实现 darknet 网络模型在移动端的快速部署</p>\n<p><a href=\"https://gitee.com/damone/darknet2ncnn\" target=\"_blank\" rel=\"noopener noreferrer\">码云</a> : <a href=\"https://gitee.com/damone/darknet2ncnn\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitee.com/damone/darknet2ncnn</a></p>","y":"a","t":"Darknet2ncnn 网络模型在移动端的快速部署"},["/blog/dnn/pub-02","/blog/dnn/pub-02.md"]],
  ["v-02793d87","/blog/dnn/pub-03.html",{"c":["工作总结","NCNN","车牌识别","深度学习"],"e":"<figure><figcaption>logo</figcaption></figure>\n<p>Mobile-LPR 是一个面向移动端的准商业级车牌识别库，以 NCNN 作为推理后端，使用 DNN 作为算法核心，支持多种车牌检测算法，支持车牌识别和车牌颜色识别。</p>\n<p>Android Demo 见 example/android-example</p>\n<h2> 特点</h2>\n<ul>\n<li>超轻量，核心库只依赖 NCNN，并且对模型量化进行支持</li>\n<li>多检测，支持 SSD,MTCNN,LFFD 等目标检测算法</li>\n<li>精度高，LFFD 目标检测在 CCPD 检测 AP 达到 98.9，车牌识别达到 99.95%， 综合识别率超过 99%</li>\n<li>易使用，只需要 10 行代码即可完成车牌识别</li>\n<li>易扩展，可快速扩展各类检测算法</li>\n</ul>","y":"a","t":"MobileLPR 移动端的准商业级车牌识别库"},["/blog/dnn/pub-03","/blog/dnn/pub-03.md"]],
  ["v-042e1626","/blog/dnn/pub-04.html",{"c":["工作总结","CNET","深度学习"],"e":"<figure><figcaption></figcaption></figure>\n<p>CNET 是一个 C99 开发的的面向 iot 设备设计的深度学习推理库，实现深度学习算法在 iot 设备上的快速部署。</p>\n<h2> 1 使命</h2>\n<p>CNET 为 IOT 的 DNN 而生，是业界首个面向 IoT 完善的 dnn 框架</p>\n<h2> 2 主要特点</h2>\n<ul>\n<li>C 语言开发， 极高的性能和兼容性</li>\n<li>极简设计，高效的内存管理，清晰的架构设计</li>\n<li>易于扩展，模块话设计，轻松完成裁剪和扩展</li>\n<li>轻便， 完整的二进制库不到 300kb</li>\n<li>可靠，完善的内存监测测试， 保证无内存泄露</li>\n<li>完善，提供高达 60 种操作实现，支持现有的大量模型</li>\n<li>高效，汇编优化，KPU 支持</li>\n</ul>","y":"a","t":"CNET IOT深度学习推理库"},["/blog/dnn/pub-04","/blog/dnn/pub-04.md"]],
  ["v-36020aff","/blog/dnn/",{"y":"p","t":"深度学习","i":"simple-icons:cnn","I":0},["/blog/dnn/index.html","/blog/dnn/README.md"]],
  ["v-75a490c8","/blog/application/application-01.html",{"c":["工作总结","智慧黑板"],"e":"<h3> 1 功能概述</h3>\n<blockquote>\n<p>智慧黑板。</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<h3> 2 设计思路</h3>\n<blockquote>\n<p>监控终端子系统的设计思路如下图所示：</p>\n</blockquote>\n<figure><figcaption></figcaption></figure>\n<blockquote>\n<p>采用插件方式进行组织，这样做可以降低模块之间的依赖，方便模块进行单独的构建和维护；</p>\n</blockquote>\n<blockquote>\n<p>从层次上讲，可以划分为基础服务层与界面交互层，基础服务层包括插件管理器、配置管理插件、日志服务插件、多语言支持插件、ClientAPI 插件等；界面交互层构建于基础服务层之上，包括 UI 界面插件管理、UI 界面统一渲染插件及若干界面插件组成；</p>\n</blockquote>","y":"a","t":"智慧黑板"},["/blog/application/application-01","/blog/application/application-01.md"]],
  ["v-77596967","/blog/application/application-02.html",{"c":["工作总结","Android","应用升级"],"e":"<p>系统总体可看成两部分组成，升级管理后台及车载终端系统，二者通过网络进行交互。终端部分又包括终端升级管理程序及终端运行程序，本文档主要针对终端升级管理程序的设计及实现, 终端升级管理程序主要包括，APP 升级， 协议升级，升级管理及跟踪，终端运行监控。</p>\n<figure><figcaption></figcaption></figure>\n<h2> 2.1&nbsp;&nbsp; 终端模块详细设计图</h2>\n<figure><figcaption></figcaption></figure>\n<h2> 2.2&nbsp;&nbsp; 终端升级管理详细流程图</h2>\n<figure><figcaption></figcaption></figure>","y":"a","t":"程序终端升级管理客户端"},["/blog/application/application-02","/blog/application/application-02.md"]],
  ["v-790e4206","/blog/application/application-03.html",{"c":["工作总结","手势识别","图像处理","目标跟踪"],"e":"<p>对于手势的提取主要的目的是将手势从较为复杂的环境中提取出来，由于环境复杂直接采取灰度图像二值化一帮无法取得较好的效果。虽然通过颜色手套的方法来解决这个问题能取得较好的效果，但是又引入了不必要的麻烦.</p>\n<p>经过综合考虑，在设计中我们采用肤色提取手势轮廓的方法，经过实验，该方法效果较为明显，在大多数的情况下都能取得较为满意的效果。对于手势的跟踪则采取预测和重定位的形式，在以往的实验中，有人采用光流法进行跟踪，由于其易受环境的影响，效果并不明显，还有就是采用 camshift 跟踪算法 + kalman 滤波算法对随机物体进行跟踪，但是它对于高速运动的物体，或运动不具有线性性质的物体跟踪存在很大的弊端，不具有很好的适应性，对此我们采用了更高级的跟踪算法，基于卡拉曼滤波的粒子滤波算法，该算法对于随机运动的物体的跟踪具有优良的效果，同时可以跟踪多个物体，可以满足手势识别的需求。</p>","y":"a","t":"手势识别跟踪算法"},["/blog/application/application-03","/blog/application/application-03.md"]],
  ["v-7c96dc53","/blog/application/",{"y":"p","t":"应用开发","i":"memory:application-code","I":0},["/blog/application/index.html","/blog/application/README.md"]],
  ["v-641d96d9","/blog/operation-system/linux-01.html",{"c":["工作总结","Linux","M5-MIPS"],"e":"<p>M5模拟器对MIPS指令集的支持限制为32位、小字节序，因此在制作交叉编译工具\n链时需要注意正确的字节序。文中的工具链基于linux-2.6.32、binutils-2.22、glibc-2.13、\nglibc-ports-2.13、gcc-4.4.6、gmp-5.0.0、mpfr-3.0.1构建。</p>\n<h2> 1. 创建宿主机编译环境</h2>\n<p>执行su命令，切换至root权限。执行以下命令，将相关配置信息写入到环境变量。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><pre class=\"language-bash\"><code><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">CROSSROOT</span><span class=\"token operator\">=</span>/opt/mips-cross\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">TARGET</span><span class=\"token operator\">=</span>mipsel-unknown-linux-gnu\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">PREFIX</span><span class=\"token operator\">=</span><span class=\"token variable\">${CROSSROOT}</span>/tools\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">TARGET_PREFIX</span><span class=\"token operator\">=</span><span class=\"token variable\">${PREFIX}</span>/<span class=\"token variable\">${TARGET}</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token variable\">${PREFIX}</span>/bin:<span class=\"token variable\">${<span class=\"token environment constant\">PATH</span>}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"M5-MIPS交叉编译环境搭建"},["/blog/operation-system/linux-01","/blog/operation-system/linux-01.md"]],
  ["v-5c078686","/blog/operation-system/",{"y":"p","t":"操作系统","i":"icon-park-outline:system","I":0},["/blog/operation-system/index.html","/blog/operation-system/README.md"]],
  ["v-7741fa30","/blog/operation-system/windows-01.html",{"c":["工作总结","透明加密"],"e":"<p>本系列博客将详细概述一个透明加密系统的设计及实现过程，其中涉及大量的 windows 内核知识，本系列博客将从基本的背景开始，详细介绍透明加密系统的发展情况及应用背景，然后介绍相关的内核开发知识，透明加密系统的关键技术解读，透明加密系统的整体设计及实现，以及基本的功能测试、性能测试及兼容性测试。</p>\n<ol>\n<li>博客涉及的程序都是个人学生时代的作品，只是作为分享及参考，不具有实用性；</li>\n<li>本人不是 Windows 操作系统专家，涉及到的操作系统底层的相关知识如果存在问题，欢迎各位大神指导；</li>\n<li>有感兴趣的欢迎一起研究，一起完善内核模块，提升技术；</li>\n</ol>","y":"a","t":"透明加密系统设计及实现-说明及目录"},["/blog/operation-system/windows-01","/blog/operation-system/windows-01.md"]],
  ["v-73d848f2","/blog/operation-system/windows-02.html",{"c":["工作总结","透明加密"],"e":"<p>随着信息时代的到来，计算机成为了人们日常生活的必备之物。大量的桌面计算机和移动终端设备给人们带来了极大的方便，但是也增加的个人的机密信息泄密的可能性。特别是对于机密部门的机密资料和企业公司的核心技术等更容易通过信息技术的通道泄密，信息技术安全面临着前所未有的挑战。通常的网络隔离及网络防火墙很难再满足需求，因为最好的防火墙永远也抵不过社会工程学的釜底抽薪，人事的问题在目前的网络技术下是一个永生的话题。</p>\n<p>那么这样才能更好地解决这个问题呢，一切问题的解决思路都要归根到事物的本源。信息是根本，而信息本身的载体更是依托，把握住电子信息的主要信息的载体就是文件保护的关键。文件作为电子信息的主要载体，文件的泄漏就代表了信息的泄漏。解决文件泄密的最为主要的方法是对文件进行加密，但是静态的加密是一种不可控的方法，是一种非实时的，可用性极低的技术。而动态加密是解决这个问题的最根本的方法，动态加密也称透明加密，是在文件使用时加密，是一种使用时加密技术，具有很强的控制能力，文件在脱离了布置透明加密的系统时是无法使用的，具有很强的控制性。</p>","y":"a","t":"透明加密系统设计及实现-绪论"},["/blog/operation-system/windows-02","/blog/operation-system/windows-02.md"]],
  ["v-706e97b4","/blog/operation-system/windows-03.html",{"c":["工作总结","透明加密"],"e":"<p>本文主要介绍 Windows 内核的基本结构，了解 Windows 的基本结构是进行内核编程的必不可少的内容。透明文件加密系统最为核心的单元是采用 Windwos 内核过滤驱动进行设计和实现的，故而必须准确认识和理解 Windwos 内核驱动模型的原理才能设计出合理高效的透明加密的驱动程序。过滤驱动位于文件系统驱动及 I/O 管理器之间，进行透明解密、文件控制及用户控制时需要和操作系统内核的其他关键的部件进行交互，同时必须对操作系统的存储结构、缓存结构及 I/O 流程有比较深入的了解，才能设计和实现出一款效率高、稳定性好的透明加密系统。内核编程难度大，不易把握，为了更好地理解系统的实现，本章简要地介绍了内核编程的一些基本方法，包括内核模式下字符的管理、内存的分配及的进程的同步互斥的控制方法。要开发一款软件，特别是系统软件，没有有效的构建和调试环境，一切都是纸上谈兵，为此，本章最后给出了构建编译环境及调试驱动环境的基本方法，以供参考。</p>","y":"a","t":"透明加密系统设计及实现-WINDOWS内核分析及编程方法"},["/blog/operation-system/windows-03","/blog/operation-system/windows-03.md"]],
  ["v-6d04e676","/blog/operation-system/windows-04.html",{"c":["工作总结","透明加密"],"e":"<p>在第一章已经详细地介绍了透明解密系统的主要发展状况，目前市面上的透明加密系统，大多存在兼容性差和移植麻烦的情况。最为主要的是目前的透明加密系统，缺乏有效的身份认证机制，导致透明加密系统的安全性受到了极大的影响。本章结合 Minifilter 和 LayerBSD 设计思想，详细地分析了透明加密系统的基本结构和原理，给出了有效的关键信息标识的方法。研究了内核模式与用户模式便捷的通信模型，详细给出了多种透明加密系统核心部分的结构并分析它们之间的优缺点，最后综合透明加密系统的整个架构，给出了一套高度可信的身份验证机制。</p>\n<h2> 1 文件透明加密系统的基本原理</h2>\n<p>文件透明加密是指用户在操作的时候，虽然后台在自动的进行加解密，但是用户根本不知道加密及解密的存在，就像中间的隔了一层屏幕辐射过滤膜一样，用户感觉到不到它的存在。如图 1，在布置了透明加密的系统中，在进行文件 I/O 操作时，文件透明加密系统进行透明加解密，上层的已经授权的进程能够获取到文件的明文，非授权的进程仍然无法获取到文件的明文，故而防止了通过其它的进程获取文件明文并将其通过网络将文件传递到系统之外。在文件 I/O 过程中，文件透明加密及解密驱动会进行文件 I/O 进行过滤，拦截满足策略的 I/O 进行文件的加密及解密等相关的操作。</p>","y":"a","t":"透明加密系统设计及实现-透明加密的关键技术"},["/blog/operation-system/windows-04","/blog/operation-system/windows-04.md"]],
  ["v-583f07bb","/computer-science/data-structure/",{"y":"p","t":"数据结构","i":"ph:tree-structure-bold","I":0},["/computer-science/data-structure/index.html","/computer-science/data-structure/README.md"]],
  ["v-74f9725f","/computer-science/data-structure/00.%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA.html",{"c":["计算机科学","数据结构"],"e":"<h2> 0.1 数据结构基本概念</h2>\n<h3> 0.1.1 基本概念和术语</h3>\n<table>\n<thead>\n<tr>\n<th>术语</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据</td>\n<td>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</td>\n</tr>\n<tr>\n<td>数据元素</td>\n<td>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，含有多个数据项</td>\n</tr>\n<tr>\n<td>数据项</td>\n<td>是构成数据元素的不可分割的最小单位</td>\n</tr>\n<tr>\n<td>数据对象</td>\n<td>具有相同性质的数据元素的集合，是数据的一个子集</td>\n</tr>\n<tr>\n<td>数据类型</td>\n<td>一个值的集合和定义在此集合上的一组操作的总称 {原子类型、结构类型、抽象数据类型}</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>相互之间存在一种或多种特定关系的数据元素的集合</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"0. 绪论"},["/computer-science/data-structure/00.绪论/0.绪论.html","/computer-science/data-structure/00.%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA","/computer-science/data-structure/00.绪论/0.绪论.md","/computer-science/data-structure/00.%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA.md"]],
  ["v-17056428","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1%E7%BA%BF%E6%80%A7%E8%A1%A8.html",{"c":["计算机科学","数据结构"],"e":"<figure><img src=\"/images/datastruct/1.png\" alt=\"线性表\" tabindex=\"0\" loading=\"lazy\"><figcaption>线性表</figcaption></figure>\n<h3> 一、线性表的定义:</h3>\n<p><code>线性表</code>是n个具有相同特性的数据元素的有限序列。</p>\n<h3> 二、线性表的基本操作</h3>\n<p><code>注</code>：参数代“&amp;”表示引用，作用相当于指针，但更安全</p>\n<p>对数据的操作：创销，增删查改</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token function\">InitList</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//初始化表：构造一个空的线性表L，分配内存空间</span>\n<span class=\"token function\">DestoryList</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//销毁操作：销毁线性表，并释放线性表L所占用的内存空间</span>\n\n<span class=\"token function\">ListInsert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>L<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//插入操作：在表L中第i个位置上查入指定元素e</span>\n<span class=\"token function\">ListDelete</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>L<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//删除操作：删除表L中第i个位置的元素，/*并用e反回删除元素的值*/</span>\n\n<span class=\"token function\">LocateElem</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">,</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//按值查找操作</span>\n<span class=\"token function\">GetElem</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//按位查找操作</span>\n\n<span class=\"token comment\">//其它常用操作</span>\n<span class=\"token function\">Length</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//求表长</span>\n<span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//输出操作</span>\n<span class=\"token function\">Empty</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//判空操作</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"1.1 线性表"},["/computer-science/data-structure/01.线性表/1.1线性表.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1%E7%BA%BF%E6%80%A7%E8%A1%A8","/computer-science/data-structure/01.线性表/1.1线性表.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1%E7%BA%BF%E6%80%A7%E8%A1%A8.md"]],
  ["v-37db839a","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA.html",{"c":["计算机科学","数据结构"],"e":"<h3> 1.2.1 顺序表的定义</h3>\n<p><code>顺序表</code>：线性表的<code>顺序存储</code>，它是用一组地址连续的存储单元依次存储线性表中的数据元素，使得<strong>逻辑上相邻的两个元素在物理位置上也相邻</strong>。</p>\n<h3> 1.2.2 顺序表的特点</h3>\n<p>①随机访问：可直接通过下标访问</p>\n<p>②存储密度高：每个节点只能存数据元素</p>\n<p>③拓展容量不方便：即便采用动态分配方式，迁移数据时时间复杂度也比较高</p>\n<p>④插入、删除操作不方便：需要移动大量元素</p>\n<h3> 1.2.3 顺序表的实现方式</h3>","y":"a","t":"1.2 线性表的顺序表示"},["/computer-science/data-structure/01.线性表/1.2线性表的顺序表示.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA","/computer-science/data-structure/01.线性表/1.2线性表的顺序表示.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA.md"]],
  ["v-57d4b898","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.html",{"c":["计算机科学","数据结构"],"e":"<h3> 1.3.1 单链表的定义</h3>\n<p><code>单链表</code>：线性表的<code>链式存储</code>，它是通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻。</p>\n<h3> 1.3.2 单链表的特点</h3>\n<p>①不能随机访问：遍历查找访问</p>\n<p>②存储密度不高：每个节点既要存数据元素又要存指针</p>\n<p>③拓展容量方便：直接用建立单链表拓展</p>\n<p>④插入、删除操作方便：知道位置直接插入和删除</p>\n<h3> 1.3.3 单链表的实现方式</h3>\n<p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p>","y":"a","t":"1.3 线性表的链式存储"},["/computer-science/data-structure/01.线性表/1.3线性表的链式存储.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8","/computer-science/data-structure/01.线性表/1.3线性表的链式存储.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.md"]],
  ["v-11eb1c27","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.4%E5%8F%8C%E9%93%BE%E8%A1%A8.html",{"c":["计算机科学","数据结构"],"e":"<h3> 1.4.1 单链表的定义</h3>\n<p>单链表的结点中只有一个指向其后继的指针，使得单链表要访问某个结点的前驱结点时，只能从头开始遍历，访问后驱结点的复杂度为O(1)，访问前驱结点的复杂度为O(n)。为了克服上述缺点，引入了双链表。</p>\n<p><code>双链表</code>的结点中有两个指针<code>prior</code>和<code>next</code>，分别指向前驱结点和后继结点。</p>\n<h3> 1.4.2 双链表的实现方式</h3>\n<p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p>\n<p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p>","y":"a","t":"1.4 双链表"},["/computer-science/data-structure/01.线性表/1.4双链表.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.4%E5%8F%8C%E9%93%BE%E8%A1%A8","/computer-science/data-structure/01.线性表/1.4双链表.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.4%E5%8F%8C%E9%93%BE%E8%A1%A8.md"]],
  ["v-7bfa983e","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.5%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.html",{"c":["计算机科学","数据结构"],"e":"<h3> 1.5.1 循环链表的定义</h3>\n<p><code>循环链表</code>：一般包括循环循环链表和循环循环链表，如下图所示</p>\n<figure><img src=\"/images/datastruct/2021041814455792.jpg\" alt=\"循环链表\" tabindex=\"0\" loading=\"lazy\"><figcaption>循环链表</figcaption></figure>\n<h3> 1.5.2 循环链表的实现方式</h3>\n<p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p>\n<p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p>","y":"a","t":"1.5 循环链表"},["/computer-science/data-structure/01.线性表/1.5循环链表.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.5%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8","/computer-science/data-structure/01.线性表/1.5循环链表.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.5%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.md"]],
  ["v-2b38b758","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.6%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.html",{"c":["计算机科学","数据结构"],"e":"<h3> 1.6.1 静态链表的定义</h3>\n<p><code>静态链表</code>借助<code>数组</code>来描述线性表的链式存储结构，结点也有<code>数据域data</code>和<code>指针域next</code>，这里的指针是结点的<code>相对地址（数组下标）</code>，又称<code>游标</code>。和顺序表一样，静态链表也需要预先分配一块连续的内存空间。</p>\n<figure><img src=\"/images/datastruct/20210418162136494.png\" alt=\"静态链表\" tabindex=\"0\" loading=\"lazy\"><figcaption>静态链表</figcaption></figure>","y":"a","t":"1.6 静态链表"},["/computer-science/data-structure/01.线性表/1.6静态链表.html","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.6%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8","/computer-science/data-structure/01.线性表/1.6静态链表.md","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/1.6%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.md"]],
  ["v-7dd883f5","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1%E6%A0%88.html",{"e":"<h1> 2.1 栈</h1>\n<h2> 2.1.1 栈的定义</h2>\n<p><code>栈</code>是线性表结构的一种，但是栈结构的插入与删除操作都只能从同一端进行，所以栈结构是一种受限制的线性表结构，数据的插入与删除符合LIFO的原则（也就是<code>后进先出</code>，<code>先进后出</code>）。</p>\n<figure><img src=\"/images/datastruct/20200317151355505.png#pic_center\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>","y":"a","t":"2.1 栈"},["/computer-science/data-structure/02.栈和队列/2.1栈.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1%E6%A0%88","/computer-science/data-structure/02.栈和队列/2.1栈.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1%E6%A0%88.md"]],
  ["v-bba501d8","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.html",{"e":"<h1> 2.2 栈的顺序存储</h1>\n<h2> 2.2.1 顺序栈的定义</h2>\n<p><code>顺序栈</code>：栈的<code>顺序存储</code>。</p>\n<h2> 2.2.2 顺序栈的实现方式</h2>\n<p>实现方式：<code>静态分配</code>和<code>动态分配</code></p>\n<h2> 2.2.3 静态分配的顺序栈上的操作</h2>\n<h2> 顺序栈的类型描述</h2>\n<div class=\"language-C line-numbers-mode\" data-ext=\"C\"><pre class=\"language-C\"><code>#define MaxSize 10\ntypedef struct{\n\tElemtype data[MaxSize];//静态数组存放栈中元素\n\tint top;               //栈顶指针\n}SqStack;\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"2.2 栈的顺序存储"},["/computer-science/data-structure/02.栈和队列/2.2栈的顺序存储.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8","/computer-science/data-structure/02.栈和队列/2.2栈的顺序存储.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.md"]],
  ["v-5d7230af","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.html",{"e":"<h1> 2.3 栈的链式存储</h1>\n<h2> 2.3.1 链栈的定义</h2>\n<p><code>链栈</code>：栈的<code>链式存储</code>。</p>\n<h2> 2.3.2 链栈的实现方式</h2>\n<p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p>\n<p>不带头结点：写操作代码麻烦，要区分第一个数据和后续数据的处理</p>\n<p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p>\n<p><code>注</code>：这两种方式：只有类型描述一样，初始化不一样，</p>\n<p>​           判空、入栈、出栈、取栈顶元素不一样，不带头节点是s，带头结点是s-&gt;next，因为链栈以<code>链头</code>为<code>栈顶</code></p>","y":"a","t":"2.3 栈的链式存储"},["/computer-science/data-structure/02.栈和队列/2.3栈的链式存储.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8","/computer-science/data-structure/02.栈和队列/2.3栈的链式存储.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.md"]],
  ["v-3aa130e7","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.4%E9%98%9F%E5%88%97.html",{"e":"<h1> 2.4 队列</h1>\n<h2> 2.4.1 队列的定义</h2>\n<p><code>队列</code>是只允许在一端进行插入，在另一端进行删除的线性表（<code>先进先出</code>，<code>后进后出</code>）</p>\n<figure><img src=\"/images/datastruct/1-140G31P93Y96.jpg\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<h2> 2.4.2 队列的基本操作</h2>\n<p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p>","y":"a","t":"2.4 队列"},["/computer-science/data-structure/02.栈和队列/2.4队列.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.4%E9%98%9F%E5%88%97","/computer-science/data-structure/02.栈和队列/2.4队列.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.4%E9%98%9F%E5%88%97.md"]],
  ["v-c84410f8","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.5%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.html",{"e":"<h1> 2.6 队列的顺序存储</h1>\n<h2> 2.6.1 序队列的定义</h2>\n<p><code>顺序队列</code>：队列的<code>顺序存储</code>。</p>\n<h2> 2.6.2 顺序队列的实现方式</h2>\n<p>实现方式：<code>静态分配</code>和<code>动态分配</code></p>\n<p><code>注</code>：这两种方式：只是类型描述和初始化不一样，判空、入队、出队、取队头操作都一样</p>\n<h2> 2.6.3 顺序队列上的操作</h2>\n<p>以<code>循环队列</code>为主</p>\n<h2> 静态分配的顺序队列：类型描述和初始化</h2>","y":"a","t":"2.6 队列的顺序存储"},["/computer-science/data-structure/02.栈和队列/2.5队列的顺序存储.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.5%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8","/computer-science/data-structure/02.栈和队列/2.5队列的顺序存储.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.5%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.md"]],
  ["v-42706d41","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.6%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.html",{"e":"<h1> 2.7 队列的链式存储</h1>\n<h2> 2.7.1 链队列的定义</h2>\n<p><code>链队列</code>：队列的<code>链存储</code>。</p>\n<h2> 2.7.2 链队列的实现方式</h2>\n<p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p>\n<p><code>注</code>：这两种方式：类型描述相同，初始化和判空不同</p>\n<p>​\t\t   入队，不带头节点要对第一个特殊处理</p>\n<p>​           出队，取队头元素不一样，不带头节点是Q.front，带头结点是Q.front-&gt;next，因为链队以<code>链头</code>为<code>队头</code></p>","y":"a","t":"2.7 队列的链式存储"},["/computer-science/data-structure/02.栈和队列/2.6队列的链式存储.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.6%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8","/computer-science/data-structure/02.栈和队列/2.6队列的链式存储.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.6%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.md"]],
  ["v-5e0eb1bb","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.7%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html",{"e":"<h1> 2.8 双端队列</h1>\n<h2> 2.8.1 双端队列的定义</h2>\n<p><code>线性表</code>：任何位置插入删除</p>\n<p>栈、队列、双端队列都是只能两端插入删除的线性表</p>\n<p><code>栈</code>：一端插入删除</p>\n<p><code>共享栈</code>：栈的变种，两端为栈底，中间为栈顶，只能两端向中间插入删除</p>\n<p><code>队列</code>：一端插入，另一端删除</p>\n<p><code>双端队列</code>：两端都可插入删除</p>\n<p><code>输入受限的双端队列</code>：一端插入，两端删除</p>\n<p><code>输出受限的双端队列</code>：两端插入，一端删除</p>","y":"a","t":"2.8 双端队列"},["/computer-science/data-structure/02.栈和队列/2.7双端队列.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.7%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97","/computer-science/data-structure/02.栈和队列/2.7双端队列.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.7%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.md"]],
  ["v-60967cbc","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8.html",{"e":"<h1> 2.8 栈和队列的应用</h1>\n<h2> 2.8.1 栈的应用</h2>\n<h2> 栈在括号匹配中的应用</h2>\n<ol>\n<li>初始设置一个空栈，顺序读入括号</li>\n<li>若是右括号，则或者置于栈顶的最急迫期待得以消解，或者是不合法的情况</li>\n<li>若是左括号，则作为一个新的更急迫的期待压入栈中</li>\n<li>算法结束时，栈为空，否则括号序列不匹配</li>\n</ol>\n<h2> 表达式求值(中缀表达式求值)</h2>\n<p>三种表达式：<code>中缀表达式</code>、<code>后缀表达式</code>、<code>前缀表达式</code></p>\n","y":"a","t":"2.8 栈和队列的应用"},["/computer-science/data-structure/02.栈和队列/2.8栈和队列的应用.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8","/computer-science/data-structure/02.栈和队列/2.8栈和队列的应用.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8.md"]],
  ["v-f8dc8e96","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.9%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.html",{"e":"<h1> 2.9 特殊矩阵的压缩存储</h1>\n<h2> 2.9.1 数组的存储结构</h2>\n<p><code>一维数组</code>：<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span>\n逻辑上连续存放，物理上（内存中）也连续存放\n数组元素<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>的<code>物理地址=LOC+i*sizeof(ElemType)</code></p>","y":"a","t":"2.9 特殊矩阵的压缩存储"},["/computer-science/data-structure/02.栈和队列/2.9特殊矩阵的压缩存储.html","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.9%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8","/computer-science/data-structure/02.栈和队列/2.9特殊矩阵的压缩存储.md","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.9%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.md"]],
  ["v-f3ef2ce0","/computer-science/data-structure/03.%E4%B8%B2/3.1%E4%B8%B2.html",{"e":"<h1> 3.1. 串，即字符串</h1>\n<h2> 3.1.1 串的定义</h2>\n<p><code>串</code>是一种特殊的<code>线性表</code>，串的<code>数据对象</code>限定为<code>字符集</code></p>\n<h2> 3.1.2 串的基本操作</h2>\n<p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p>\n<p>对数据的操作：创销，增删查改</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token function\">StrAssign</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>τ chars<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//赋值操作。把串T赋值为chars</span>\n<span class=\"token function\">StrCopy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>TS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">//复制操作。由串S复制得到串T。</span>\n<span class=\"token function\">StrEmpty</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">//判空操作。若S为空串,则返回TRUE,否则返回 FALSE。</span>\n<span class=\"token function\">StrEngth</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">//求串长。返回串S的元素个数</span>\n<span class=\"token function\">ClearString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//清空操作。将S清为空串。</span>\n<span class=\"token function\">Destroystring</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//销毁串。将串S销毁(回收存储空间)。</span>\n<span class=\"token function\">Concat</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>TS1<span class=\"token punctuation\">,</span> S2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//串联接。用T返回由S1和S2联接而成的新串</span>\n<span class=\"token function\">SubString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sub<span class=\"token punctuation\">,</span>S<span class=\"token punctuation\">,</span> pos<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t<span class=\"token comment\">//求子串。用Sub返回串S的第pos个字符起长度为|en的子串。</span>\n<span class=\"token function\">ndex</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">//定位操作。若主串S中存在与串T值相同的子串,则返回它在主串S中第一次出现的位置;否则函数值为0。</span>\n<span class=\"token function\">StrCompare</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//比较操作。若S&gt;T,则返回值&gt;0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0。</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"3.1. 串，即字符串"},["/computer-science/data-structure/03.串/3.1串.html","/computer-science/data-structure/03.%E4%B8%B2/3.1%E4%B8%B2","/computer-science/data-structure/03.串/3.1串.md","/computer-science/data-structure/03.%E4%B8%B2/3.1%E4%B8%B2.md"]],
  ["v-dc9f89c0","/computer-science/data-structure/03.%E4%B8%B2/3.2%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.html",{"e":"<h1> 3.2 串的存储结构</h1>\n<h2> 3.2.1 串的存储结构</h2>\n<p><code>顺序存储</code>和<code>链式存储</code></p>\n<h2> 3.2.2 串的顺序存储的实现方式</h2>\n<p>实现方式：<code>静态分配</code>和<code>动态分配</code>，一般用动态分配</p>\n<h3> 串的类型描述：</h3>\n<h4> 静态分配：SString</h4>\n<div class=\"language-C line-numbers-mode\" data-ext=\"C\"><pre class=\"language-C\"><code>#define MAXLEN 255;\t\t\t //定义最大长度\ntypedef struct{\n    char ch[MAXLEN];         //“静态”的数组存数据，存字符\n    int length;              //串的实际长度\n}SString;\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"3.2 串的存储结构"},["/computer-science/data-structure/03.串/3.2串的存储结构.html","/computer-science/data-structure/03.%E4%B8%B2/3.2%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84","/computer-science/data-structure/03.串/3.2串的存储结构.md","/computer-science/data-structure/03.%E4%B8%B2/3.2%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.md"]],
  ["v-a63c711c","/computer-science/data-structure/03.%E4%B8%B2/3.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.html",{"e":"<h1> 3.3 字符串模式匹配</h1>\n<p><code>字符串模式匹配</code>：在<code>主串</code>中找到与<code>模式串</code>相同的子串,并返回其所在位置。</p>\n<p><code>子串</code>：一定能在主串中找到的串</p>\n<p><code>模式串</code>：不一定能在主串中找到的串</p>\n<p>方法：<code>朴素模式匹配算法</code>和<code>KMP算法</code></p>\n<h2> 3.3.1 朴素模式匹配算法</h2>\n<h3> 用串的定位操作：</h3>\n<p>方法：在S中依次按顺序取m长子串，判断是否与T相同</p>","y":"a","t":"3.3 字符串模式匹配"},["/computer-science/data-structure/03.串/3.3字符串模式匹配.html","/computer-science/data-structure/03.%E4%B8%B2/3.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D","/computer-science/data-structure/03.串/3.3字符串模式匹配.md","/computer-science/data-structure/03.%E4%B8%B2/3.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.md"]],
  ["v-32d1e072","/computer-science/data-structure/04.%E6%A0%91/4.1%E6%A0%91.html",{"e":"<h1> 4.1 树</h1>\n<h2> 4.1.1 树的定义：</h2>\n<p><code>树</code>是η(n≥0)个结点的有限集合,n≡o时,称为空树,这是一种特殊情况。在任意一棵非空树中应满足:\n①有且仅有一个特定的称为根的<code>结点</code>。\n②当n&gt;1时,其余结点可分为m(m&gt;0)个互不相交的有限集合T1,T2…,Tn,其中每个集合本身又是一棵树,并且称为根结点的<code>子树</code>。</p>\n<figure><img src=\"/images/datastruct/20180801094313847.jfif\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>","y":"a","t":"4.1 树"},["/computer-science/data-structure/04.树/4.1树.html","/computer-science/data-structure/04.%E6%A0%91/4.1%E6%A0%91","/computer-science/data-structure/04.树/4.1树.md","/computer-science/data-structure/04.%E6%A0%91/4.1%E6%A0%91.md"]],
  ["v-5f84de7b","/computer-science/data-structure/04.%E6%A0%91/4.2%E4%BA%8C%E5%8F%89%E6%A0%91.html",{"e":"<h1> 4.2 二叉树</h1>\n<h2> 4.2.1 二叉树的定义：</h2>\n<p><code>二叉树</code>是n(n≥0)个结点的有限集合\n①或者为空二叉树，即n=0。\n②或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树\n特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）</p>\n<figure><img src=\"/images/datastruct/2-1Q226195I0M1.gif\" alt=\"二叉树示意图\" tabindex=\"0\" loading=\"lazy\"><figcaption>二叉树示意图</figcaption></figure>","y":"a","t":"4.2 二叉树"},["/computer-science/data-structure/04.树/4.2二叉树.html","/computer-science/data-structure/04.%E6%A0%91/4.2%E4%BA%8C%E5%8F%89%E6%A0%91","/computer-science/data-structure/04.树/4.2二叉树.md","/computer-science/data-structure/04.%E6%A0%91/4.2%E4%BA%8C%E5%8F%89%E6%A0%91.md"]],
  ["v-28d90276","/computer-science/data-structure/04.%E6%A0%91/4.3%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.html",{"e":"<h1> 4.3 线索二叉树</h1>\n<h2> 4.3.1 线索二叉树定义</h2>\n<p>背景：为解决遍历只能从根结点开始这个问题，因为普通二叉树找前驱和后继很麻烦</p>\n<p><code>线索二叉树</code>在二叉树的结点上加上<code>线索</code>的二叉树。</p>\n<h2> 4.3.2 线索二叉树的存储结构</h2>\n<p>由二叉树的链式存储改进而来</p>\n<h3> 二叉树的类型表述</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">{</span>\n\tElemtype data<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">//数据域</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">BiTNode</span> <span class=\"token operator\">*</span>lchide<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>rchild<span class=\"token punctuation\">;</span> <span class=\"token comment\">//左、右孩子指针</span>\n<span class=\"token punctuation\">}</span>BiTNode<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>BiTree<span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"4.3 线索二叉树"},["/computer-science/data-structure/04.树/4.3线索二叉树.html","/computer-science/data-structure/04.%E6%A0%91/4.3%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91","/computer-science/data-structure/04.树/4.3线索二叉树.md","/computer-science/data-structure/04.%E6%A0%91/4.3%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.md"]],
  ["v-7a61223c","/computer-science/data-structure/04.%E6%A0%91/4.4%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.html",{"e":"<h1> 4.4 树的存储结构</h1>\n<h2> 4.4.1 存储结构</h2>\n<p><code>顺序存储</code>和<code>链式存储</code></p>\n<p>方法：\n<code>双亲表示法</code>（顺序存储）\n<code>孩子表示法</code>（顺序+链式存储）\n<code>孩子兄弟表示法</code>（链式存储）</p>\n<h2> 4.4.2 双亲表示法（顺序存储）</h2>\n<figure><img src=\"/images/datastruct/20200205124743184.jpg\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>","y":"a","t":"4.4 树的存储结构"},["/computer-science/data-structure/04.树/4.4树的存储结构.html","/computer-science/data-structure/04.%E6%A0%91/4.4%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84","/computer-science/data-structure/04.树/4.4树的存储结构.md","/computer-science/data-structure/04.%E6%A0%91/4.4%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.md"]],
  ["v-20f75680","/computer-science/data-structure/04.%E6%A0%91/4.5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.html",{"e":"<h1> 4.5 二叉排序树</h1>\n<h2> 4.5.1 二叉排序树的定义</h2>\n<p><code>二叉排序树</code>，又称<code>二叉查找树</code>(<code>BST</code>, <code>Binary Search Tree</code>)</p>\n<p>定义：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：\n<code>左子树</code>上所有结点的关键字均<code>小于</code> <code>根结点</code>的关键字；\n<code>右子树</code>上所有结点的关键字均<code>大于</code> <code>根结点</code>的关键字。\n左子树和右子树又各是一棵二叉排序树。</p>","y":"a","t":"4.5 二叉排序树"},["/computer-science/data-structure/04.树/4.5二叉排序树.html","/computer-science/data-structure/04.%E6%A0%91/4.5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91","/computer-science/data-structure/04.树/4.5二叉排序树.md","/computer-science/data-structure/04.%E6%A0%91/4.5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.md"]],
  ["v-0dc05d70","/computer-science/data-structure/04.%E6%A0%91/4.6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",{"e":"<h1> 4.6 平衡二叉树</h1>\n<h2> 4.6.1 平衡二叉树的定义</h2>\n<p><code>平衡二叉树</code>,又被称为<code>AVL树</code>（有别于AVL算法），且具有以下性质：</p>\n<p>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<p>AVL是两个人的名字，ASL是平均查找长度，不一样</p>\n<p><code>结点的平衡因子=左子树高-右子树高</code></p>\n<p>平衡二叉树结点的平衡因子的值只可能是-1、0、1。</p>\n<figure><img src=\"/images/datastruct//805461-20160127214903223-1113949071.jpg\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>","y":"a","t":"4.6 平衡二叉树"},["/computer-science/data-structure/04.树/4.6平衡二叉树.html","/computer-science/data-structure/04.%E6%A0%91/4.6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91","/computer-science/data-structure/04.树/4.6平衡二叉树.md","/computer-science/data-structure/04.%E6%A0%91/4.6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md"]],
  ["v-e19b0ebc","/computer-science/data-structure/04.%E6%A0%91/4.7%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.html",{"e":"<h1> 4.7 哈夫曼树</h1>\n<h2> 4.7.1 带权路径长度</h2>\n<p>结点的<code>权</code>：有某种现实含义的数值（如：结点的重要性等）</p>\n<p><code>结点的带权路径长度=该结点的路径长度×该结点的权值</code></p>\n<p><code>树的带权路径长度</code>=所有<code>叶结点</code>的<code>带权路径长度之和</code></p>\n<h2> 4.7.2 哈夫曼树的定义</h2>\n<p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的<code>带权路径长度达到最小</code>，称这样的二叉树为<code>最优二叉树</code>，也称为<code>哈夫曼树</code>(Huffman Tree)。</p>","y":"a","t":"4.7 哈夫曼树"},["/computer-science/data-structure/04.树/4.7哈夫曼树.html","/computer-science/data-structure/04.%E6%A0%91/4.7%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91","/computer-science/data-structure/04.树/4.7哈夫曼树.md","/computer-science/data-structure/04.%E6%A0%91/4.7%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.md"]],
  ["v-438178f4","/computer-science/data-structure/05.%E5%9B%BE/5.1%E5%9B%BE.html",{"e":"<h1> 5.1 图</h1>\n<h2> 5.1.1 图的定义</h2>\n<p><code>图G</code>由<code>顶点集V</code>和<code>边集E</code>组成，记<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>。</p>","y":"a","t":"5.1 图"},["/computer-science/data-structure/05.图/5.1图.html","/computer-science/data-structure/05.%E5%9B%BE/5.1%E5%9B%BE","/computer-science/data-structure/05.图/5.1图.md","/computer-science/data-structure/05.%E5%9B%BE/5.1%E5%9B%BE.md"]],
  ["v-58d6de3c","/computer-science/data-structure/05.%E5%9B%BE/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.html",{"e":"<h1> 5.2 图的存储结构</h1>\n<h2> 5.2.1 图的存储结构</h2>\n<ul>\n<li>①领接矩阵：顺序存储（一维数组存点的数据，二维数组存边的连接情况）(存储无向图、有向图)</li>\n<li>②邻接表：顺序+链式存储（顺序存点的数据，链存连接该点的边）（存储有向图、无向图）</li>\n<li>③十字链表：链式存储（存储有向图）</li>\n<li>④邻接多重表：链式存储（存储无向图）</li>\n</ul>\n<figure><img src=\"/images/datastruct/1637936258196.png\" alt=\"1637936258196\" tabindex=\"0\" loading=\"lazy\"><figcaption>1637936258196</figcaption></figure>","y":"a","t":"5.2 图的存储结构"},["/computer-science/data-structure/05.图/5.2图的存储结构.html","/computer-science/data-structure/05.%E5%9B%BE/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84","/computer-science/data-structure/05.图/5.2图的存储结构.md","/computer-science/data-structure/05.%E5%9B%BE/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.md"]],
  ["v-5c08ab16","/computer-science/data-structure/05.%E5%9B%BE/5.3%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",{"e":"<h1> 5.3 图的基本操作</h1>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token comment\">//图的基本操作</span>\n<span class=\"token function\">Adjacent</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//判断图G是否存在边&lt;x,y&gt;或(x,y)。</span>\n<span class=\"token function\">Neighbors</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">//列出图G中与结点x邻接的边。</span>\n<span class=\"token function\">InsertVertex</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//在图G中插入顶点x。</span>\n<span class=\"token function\">DeleteVertex</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//从图G中删除顶点x。</span>\n<span class=\"token function\">AddEdge</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">//若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边。</span>\n<span class=\"token function\">RemoveEdge</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//若无向边(x,y)或有向边&lt;x,y&gt;存在，则从图G中删除该边。</span>\n<span class=\"token function\">FirstNeighbor</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</span>\n<span class=\"token function\">NextNeighbor</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</span>\n<span class=\"token function\">Get_edge_value</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//获取图G中边(x,y)或&lt;x,y&gt;对应的权值。</span>\n<span class=\"token function\">Set_edge_value</span><span class=\"token punctuation\">(</span>G<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">,</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v。</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"5.3 图的基本操作"},["/computer-science/data-structure/05.图/5.3图的基本操作.html","/computer-science/data-structure/05.%E5%9B%BE/5.3%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C","/computer-science/data-structure/05.图/5.3图的基本操作.md","/computer-science/data-structure/05.%E5%9B%BE/5.3%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.md"]],
  ["v-3bf695d7","/computer-science/data-structure/05.%E5%9B%BE/5.4%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(BFS%E3%80%81DFS).html",{"e":"<h1> 5.4 图的遍历</h1>\n<h2> 5.4.1 图的遍历</h2>\n<p>广度优先遍历、深度优先遍历</p>\n<h2> 5.4.2 广度优先遍历（BFS）</h2>\n<p>与<code>树</code>的广度优先搜索（<code>层次遍历</code>）很像。</p>\n<p>需要一个<code>辅助链队列</code>。</p>\n<p>树的层次遍历的算法思想：</p>\n<ul>\n<li>①初始化一个辅助队列（链队列）</li>\n<li>②根结点入队</li>\n<li>③若队列非空，则队头结点出队，访问该结点并将其<code>左、右孩子</code>插入队尾(如果有的话)</li>\n<li>④重复③直至队列为空</li>\n</ul>","y":"a","t":"5.4 图的遍历"},["/computer-science/data-structure/05.图/5.4图的遍历(BFS、DFS).html","/computer-science/data-structure/05.%E5%9B%BE/5.4%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(BFS%E3%80%81DFS)","/computer-science/data-structure/05.图/5.4图的遍历(BFS、DFS).md","/computer-science/data-structure/05.%E5%9B%BE/5.4%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(BFS%E3%80%81DFS).md"]],
  ["v-7a23a5c6","/computer-science/data-structure/05.%E5%9B%BE/5.5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html",{"e":"<h1> 5.5 最小生成树</h1>\n<h2> 5.5.1 最小生成树的概念</h2>\n<p>连通图生成树，非连通图生成森林</p>\n<p><code>生成树</code>是包含图中全部顶点的一个<code>极小连通子图</code>\n<code>特性</code>：图中有n个顶点，则它的生成树含有n-1条边。\n去除一条边会变成非连通图；加上一条边会变成一个回路</p>\n<p>之前学过<code>广度优先生成树</code>和<code>深度优先生成树</code>。</p>\n<p><code>最小生成树</code>，也叫<code>最小代价树</code>。在带权连通无向图的所有生成树中，所有边的代价和最小。</p>","y":"a","t":"5.5 最小生成树"},["/computer-science/data-structure/05.图/5.5最小生成树.html","/computer-science/data-structure/05.%E5%9B%BE/5.5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91","/computer-science/data-structure/05.图/5.5最小生成树.md","/computer-science/data-structure/05.%E5%9B%BE/5.5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.md"]],
  ["v-97a0a08a","/computer-science/data-structure/05.%E5%9B%BE/5.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html",{"e":"<h1> 5.6 最短路径</h1>\n<figure><img src=\"/images/datastruct/1638172106501.png\" alt=\"1638172106501\" tabindex=\"0\" loading=\"lazy\"><figcaption>1638172106501</figcaption></figure>\n<figure><img src=\"/images/datastruct/1638178148141.png\" alt=\"1638178148141\" tabindex=\"0\" loading=\"lazy\"><figcaption>1638178148141</figcaption></figure>","y":"a","t":"5.6 最短路径"},["/computer-science/data-structure/05.图/5.6最短路径.html","/computer-science/data-structure/05.%E5%9B%BE/5.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84","/computer-science/data-structure/05.图/5.6最短路径.md","/computer-science/data-structure/05.%E5%9B%BE/5.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md"]],
  ["v-7937f9cb","/computer-science/data-structure/05.%E5%9B%BE/5.7%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE.html",{"e":"<h1> 5.7 有向无环图</h1>\n<h2> 5.7.1 有向无环图定义</h2>\n<p><code>有向无环图</code>：有向图中不存在环，又称<code>DAG图</code>。</p>\n<h2> 5.7.2 有向无环图描述表达式</h2>\n<p>由表达式画<code>最少顶点</code>的有向无环图：</p>\n<figure><img src=\"/images/datastruct/1638191188272.png\" alt=\"1638191188272\" tabindex=\"0\" loading=\"lazy\"><figcaption>1638191188272</figcaption></figure>","y":"a","t":"5.7 有向无环图"},["/computer-science/data-structure/05.图/5.7有向无环图.html","/computer-science/data-structure/05.%E5%9B%BE/5.7%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE","/computer-science/data-structure/05.图/5.7有向无环图.md","/computer-science/data-structure/05.%E5%9B%BE/5.7%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE.md"]],
  ["v-c8dd49c2","/computer-science/data-structure/05.%E5%9B%BE/5.8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.html",{"e":"<h1> 5.8 拓扑排序</h1>\n<h2> 5.8.1 AOV网</h2>\n<p><code>AOV网</code>（Activity On Vertex NetWork，用<code>顶点表示活动</code>的网）：\n用DAG图（<code>有向无环图</code>）表示一个工程。\n<code>顶点表示活动</code>，边<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>表示活动<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>必须先于活动<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>进行</p>","y":"a","t":"5.8 拓扑排序"},["/computer-science/data-structure/05.图/5.8拓扑排序.html","/computer-science/data-structure/05.%E5%9B%BE/5.8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F","/computer-science/data-structure/05.图/5.8拓扑排序.md","/computer-science/data-structure/05.%E5%9B%BE/5.8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.md"]],
  ["v-64ae04e8","/computer-science/data-structure/05.%E5%9B%BE/5.9%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.html",{"e":"<h1> 5.9 关键路径</h1>\n<h2> 5.9.1 AOE网</h2>\n<p><code>AOE网</code>（Activity On Edge NetWork，用<code>边表示活动</code>的网）：\n<code>带权有向图</code>中，<code>顶点表示事件</code>，<code>有向边表示活动</code>，<code>边上的权值表示完成该活动的开销</code>。</p>\n<figure><img src=\"/images/datastruct/uTools_1638194800008.png\" alt=\"uTools_1638194800008\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638194800008</figcaption></figure>","y":"a","t":"5.9 关键路径"},["/computer-science/data-structure/05.图/5.9关键路径.html","/computer-science/data-structure/05.%E5%9B%BE/5.9%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84","/computer-science/data-structure/05.图/5.9关键路径.md","/computer-science/data-structure/05.%E5%9B%BE/5.9%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84.md"]],
  ["v-5600ce8c","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.1%E6%9F%A5%E6%89%BE.html",{"c":["计算机科学","数据结构"],"e":"<h2> 6.1.1 查找的基本概念</h2>\n<p><code>查找</code>：在数据集合中寻找满足某种条件的数据元素的过程称为查找。\n<code>查找表</code>（查找结构）：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。\n<code>关键字</code>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p>\n<figure><img src=\"/images/datastruct/uTools_1638241191170.png\" alt=\"uTools_1638241191170\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638241191170</figcaption></figure>","y":"a","t":"6.1 查找"},["/computer-science/data-structure/06.查找/6.1查找.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.1%E6%9F%A5%E6%89%BE","/computer-science/data-structure/06.查找/6.1查找.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.1%E6%9F%A5%E6%89%BE.md"]],
  ["v-6ac08f22","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.2%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.html",{"c":["计算机科学","数据结构"],"e":"<h2> 6.2.1 顺序查找的定义</h2>\n<p><code>顺序查找</code>，又叫<code>线性查找</code>。</p>\n<h2> 6.2.2 顺序查找的实现</h2>\n<p><code>算法思想</code>：从头挨个查找。</p>\n<p>普通代码：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token comment\">//查找表的数据结构（动态分配的顺序表）</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span>\n    ElemType <span class=\"token operator\">*</span>elem<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//指向“动态”分配的数组的指针</span>\n    <span class=\"token keyword\">int</span> TableLen<span class=\"token punctuation\">;</span>        <span class=\"token comment\">//查找表的当前长度</span>\n<span class=\"token punctuation\">}</span>SSTable<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//顺序查找</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">Search_Seq</span><span class=\"token punctuation\">(</span>SSTable ST<span class=\"token punctuation\">,</span> ElemType key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>ST<span class=\"token punctuation\">.</span>TableLen <span class=\"token operator\">&amp;&amp;</span> ST<span class=\"token punctuation\">.</span>elem<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">!=</span>key<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token comment\">//从前往后找，判断是否越界</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token operator\">==</span>ST<span class=\"token punctuation\">.</span>TableLen<span class=\"token operator\">?</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">:</span> i<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//查找成功，则返回元素下标；查找失败，则返回-1</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"6.2 顺序查找"},["/computer-science/data-structure/06.查找/6.2顺序查找.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.2%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE","/computer-science/data-structure/06.查找/6.2顺序查找.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.2%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.md"]],
  ["v-61c68978","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.3%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE.html",{"c":["计算机科学","数据结构"],"e":"<h2> 6.3.1 折半查找的定义</h2>\n<p><code>折半查找</code>，又叫<code>二分查找</code>。仅适用于<code>有序的顺序表</code>。</p>\n<h2> 6.3.2 折半查找的实现</h2>\n<p><code>算法思想</code>：每次从中间分，判断自己是哪一半</p>\n<p>普通代码：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token comment\">//查找表的数据结构（动态分配的顺序表）</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span>\n    ElemType <span class=\"token operator\">*</span>elem<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//指向“动态”分配的数组的指针</span>\n    <span class=\"token keyword\">int</span> TableLen<span class=\"token punctuation\">;</span>        <span class=\"token comment\">//查找表的当前长度</span>\n<span class=\"token punctuation\">}</span>SSTable<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//折半查找</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">Binary_Search</span><span class=\"token punctuation\">(</span>SSTable L<span class=\"token punctuation\">,</span> ElemType key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> low <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> high <span class=\"token operator\">=</span> L<span class=\"token punctuation\">.</span>TableLen<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>low <span class=\"token operator\">&lt;=</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">+</span> high<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">//取中间值</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">.</span>elem<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>                 <span class=\"token comment\">//查找成功，则返回所在位置</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">.</span>elem<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            high <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>             <span class=\"token comment\">//从前半部分继续查</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            low <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">//从后半部分继续查</span>\n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">//查找失败，返回-1</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"6.3 折半查找"},["/computer-science/data-structure/06.查找/6.3折半查找.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.3%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE","/computer-science/data-structure/06.查找/6.3折半查找.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.3%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE.md"]],
  ["v-5b6a8154","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.4%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.html",{"c":["计算机科学","数据结构"],"e":"<h2> 6.4.1 分块查找的定义</h2>\n<p><code>分块查找</code>，又叫<code>索引顺序查找</code>。</p>\n<h2> 6.4.2 分块查找的实现的实现</h2>\n<p><code>算法思想</code>：用一个<code>索引表</code>给数据归类。</p>\n<p>算法过程：\n①在<code>索引表</code>中确定待查记录所属的分块（<code>可顺序、可折半</code>）\n②在<code>块内顺序查找</code></p>\n<figure><img src=\"/images/datastruct/uTools_1638257539381.png\" alt=\"uTools_1638257539381\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638257539381</figcaption></figure>","y":"a","t":"6.4 分块查找"},["/computer-science/data-structure/06.查找/6.4分块查找.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.4%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE","/computer-science/data-structure/06.查找/6.4分块查找.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.4%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.md"]],
  ["v-1675ae46","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.5B%E6%A0%91.html",{"c":["计算机科学","数据结构"],"e":"<figure><img src=\"/images/datastruct/uTools_1638266668727.png\" alt=\"uTools_1638266668727\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638266668727</figcaption></figure>\n<h2> 6.5.1 B树的定义</h2>\n<p><code>B树</code>，又名<code>多路平衡查找树</code>（<code>m叉查找树</code>）</p>\n<p>数据库索引技术里大量使用者B树和B+树的数据结构.</p>\n<p>B树是由<code>二叉排序树</code>升级为<code>m叉查找树</code></p>","y":"a","t":"6.5 B树"},["/computer-science/data-structure/06.查找/6.5B树.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.5B%E6%A0%91","/computer-science/data-structure/06.查找/6.5B树.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.5B%E6%A0%91.md"]],
  ["v-3bd4eaff","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.6BP%E6%A0%91.html",{"c":["计算机科学","数据结构"],"e":"<h2> 6.6.1 B+树的定义</h2>\n<p><code>B+树</code>，又名<code>多级分块查找</code>。</p>\n<p>数据库索引技术里大量使用者B树和B+树的数据结构.</p>\n<p>B+树是由<code>分块查找</code>升级为<code>查找树</code></p>\n<p>B树任何一层都可以找到，因为每一层都是数据\n而B+树除叶子结点外，其余都是分类，只有最底层才会指向数据，必须找到最底层才能知道是否成功。</p>\n<p>B+树有两种查找方式：</p>\n<ul>\n<li>分块查找：从根结点查</li>\n<li>顺序查找：从P开始横着查。</li>\n</ul>","y":"a","t":"6.6 B+树"},["/computer-science/data-structure/06.查找/6.6BP树.html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.6BP%E6%A0%91","/computer-science/data-structure/06.查找/6.6BP树.md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.6BP%E6%A0%91.md"]],
  ["v-df8185b0","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.7%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE(%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE).html",{"e":"<h1> 6.7 散列查找(哈希查找)</h1>\n<figure><img src=\"/images/datastruct/uTools_1638349184596.png\" alt=\"uTools_1638349184596\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638349184596</figcaption></figure>\n<h2> 6.7.1 哈希查找的定义</h2>\n<p><code>散列表</code>（Hash Table），又名<code>哈希表</code>，是一种数据结构。</p>\n<p><code>特点</code>：数据元素的<code>关键字与其存储地址直接相关</code>。</p>","y":"a","t":"6.7 散列查找(哈希查找)"},["/computer-science/data-structure/06.查找/6.7散列查找(哈希查找).html","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.7%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE(%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE)","/computer-science/data-structure/06.查找/6.7散列查找(哈希查找).md","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/6.7%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE(%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE).md"]],
  ["v-1d6e37de","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.1%E6%8E%92%E5%BA%8F.html",{"e":"<h1> 7.1 排序</h1>\n<h2> 常见排序算法与其时间复杂度：</h2>\n<figure><img src=\"/images/datastruct/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTgwNC84NDk1ODktMjAxODA0MDIxMzI1MzAzNDItOTgwMTIxNDA5LnBuZw.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<figure><img src=\"/images/datastruct/20210408130104795.png\" alt=\"20210408130104795\" tabindex=\"0\" loading=\"lazy\"><figcaption>20210408130104795</figcaption></figure>","y":"a","t":"7.1 排序"},["/computer-science/data-structure/07.排序/7.1排序.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.1%E6%8E%92%E5%BA%8F","/computer-science/data-structure/07.排序/7.1排序.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.1%E6%8E%92%E5%BA%8F.md"]],
  ["v-8ab02c0e","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.2 插入排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638366099368.png\" alt=\"uTools_1638366099368\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638366099368</figcaption></figure>\n<h2> 7.2.1 算法思想：</h2>\n<p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>\n<figure><img src=\"/images/datastruct/849589-20171015225645277-1151100000.gif\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>","y":"a","t":"7.2 插入排序"},["/computer-science/data-structure/07.排序/7.2插入排序（稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.2插入排序（稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-85aa9c96","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.3 希尔排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638366303933.png\" alt=\"uTools_1638366303933\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638366303933</figcaption></figure>\n<p><code>希尔排序</code>又叫<code>缩小增量排序</code>。</p>\n<p>1959年Shell发明，第一个突破<span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>的排序算法，是<code>简单插入排序的改进版</code>。它与插入排序的不同之处在于，它会<code>优先比较距离较远的元素</code>。</p>","y":"a","t":"7.3 希尔排序"},["/computer-science/data-structure/07.排序/7.3希尔排序（不稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.3希尔排序（不稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-21c6e546","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.4%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.4 冒泡排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638450353573.png\" alt=\"uTools_1638450353573\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638450353573</figcaption></figure>\n<figure><img src=\"/images/datastruct/uTools_1638449861667.png\" alt=\"uTools_1638449861667\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638449861667</figcaption></figure>","y":"a","t":"7.4 冒泡排序"},["/computer-science/data-structure/07.排序/7.4冒泡排序（稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.4%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.4冒泡排序（稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.4%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-0847e6fb","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.5 快速排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638450353573.png\" alt=\"uTools_1638450353573\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638450353573</figcaption></figure>\n<figure><img src=\"/images/datastruct/uTools_1638451646054.png\" alt=\"uTools_1638451646054\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638451646054</figcaption></figure>","y":"a","t":"7.5 快速排序"},["/computer-science/data-structure/07.排序/7.5快速排序（不稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.5快速排序（不稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-727a077c","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.6%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.6 简单选择排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638453625935.png\" alt=\"uTools_1638453625935\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638453625935</figcaption></figure>\n<figure><img src=\"/images/datastruct/uTools_1638453702968.png\" alt=\"uTools_1638453702968\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638453702968</figcaption></figure>","y":"a","t":"7.6 简单选择排序"},["/computer-science/data-structure/07.排序/7.6简单选择排序（不稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.6%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.6简单选择排序（不稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.6%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-a6b4d232","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.7%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.7 堆排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638453625935.png\" alt=\"uTools_1638453625935\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638453625935</figcaption></figure>\n<figure><img src=\"/images/datastruct/uTools_1638518610172.png\" alt=\"uTools_1638518610172\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638518610172</figcaption></figure>","y":"a","t":"7.7 堆排序"},["/computer-science/data-structure/07.排序/7.7堆排序（不稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.7%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.7堆排序（不稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.7%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-5d64e8d8","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.8 归并排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638535460811.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>归并排序</code>是建立在归并操作上的一种有效的排序算法。该算法是采用<code>分治法</code>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>\n<p>归并：把两个或多个已经有序的序列合并成一个。</p>","y":"a","t":"7.8 归并排序"},["/computer-science/data-structure/07.排序/7.8归并排序（稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.8归并排序（稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-b4a63948","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.html",{"e":"<h1> 7.9 基数排序</h1>\n<figure><img src=\"/images/datastruct/uTools_1638539983688.png\" alt=\"uTools_1638539983688\" tabindex=\"0\" loading=\"lazy\"><figcaption>uTools_1638539983688</figcaption></figure>\n<p><code>基数排序</code>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>","y":"a","t":"7.9 基数排序"},["/computer-science/data-structure/07.排序/7.9基数排序（稳定）.html","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89","/computer-science/data-structure/07.排序/7.9基数排序（稳定）.md","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89.md"]],
  ["v-6dd36a04","/computer-science/data-structure/summary/",{"c":["计算机科学","数据结构"],"e":"<h2> 0. 绪论</h2>\n<h3> 0.1 数据结构基本概念</h3>\n<h4> 0.1.1 基本概念和术语</h4>\n<table>\n<thead>\n<tr>\n<th>术语</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数据</td>\n<td>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</td>\n</tr>\n<tr>\n<td>数据元素</td>\n<td>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，含有多个数据项</td>\n</tr>\n<tr>\n<td>数据项</td>\n<td>是构成数据元素的不可分割的最小单位</td>\n</tr>\n<tr>\n<td>数据对象</td>\n<td>具有相同性质的数据元素的集合，是数据的一个子集</td>\n</tr>\n<tr>\n<td>数据类型</td>\n<td>一个值的集合和定义在此集合上的一组操作的总称 {原子类型、结构类型、抽象数据类型}</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>相互之间存在一种或多种特定关系的数据元素的集合</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"数据结构关键知识点"},["/computer-science/data-structure/summary/index.html","/computer-science/data-structure/summary/README.md"]],
  ["v-0b4d529c","/computer-science/data-structure/summary/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9.html",{"c":["计算机科学","数据结构"],"e":"<h2> 1. 常见的逻辑结构</h2>\n<ul>\n<li>线性结构：一般线性表、受限线性表（栈和队列）、线性表推广（数组）</li>\n<li>非线性结构：集合结构、树结构、图结构</li>\n</ul>\n<h2> 2.常见的存储结构</h2>\n<table>\n<thead>\n<tr>\n<th>存储结构</th>\n<th>定义</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序存储</td>\n<td>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</td>\n<td>随机存取，占用空间少</td>\n<td>使用一整块相邻的存储单元，产生较多碎片</td>\n</tr>\n<tr>\n<td>链式存储</td>\n<td>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</td>\n<td>不会出现碎片，充分利用所有存储单元</td>\n<td>需要额外空间，只能顺序存取</td>\n</tr>\n<tr>\n<td>索引存储</td>\n<td>在存储元素信息的同时，还建立附加的索引表。</td>\n<td>检索速度快</td>\n<td>附加的索引表需要额外空间。增删数据修改索引表时花费时间</td>\n</tr>\n<tr>\n<td>散列存储</td>\n<td>根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。</td>\n<td>检索、增加和删除结点的操作很快</td>\n<td>可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"数据结构核心考点"},["/computer-science/data-structure/summary/数据结构核心考点.html","/computer-science/data-structure/summary/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9","/computer-science/data-structure/summary/数据结构核心考点.md","/computer-science/data-structure/summary/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9.md"]],
  ["v-3706649a","/404.html",{"y":"p","t":""},["/404"]],
  ["v-2c029960","/computer-science/data-structure/00.%E7%BB%AA%E8%AE%BA/",{"y":"p","t":"00.绪论"},["/computer-science/data-structure/00.绪论/","/computer-science/data-structure/00.%E7%BB%AA%E8%AE%BA/index.html"]],
  ["v-118fb51a","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/",{"y":"p","t":"01.线性表"},["/computer-science/data-structure/01.线性表/","/computer-science/data-structure/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html"]],
  ["v-0f8386d2","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/",{"y":"p","t":"02.栈和队列"},["/computer-science/data-structure/02.栈和队列/","/computer-science/data-structure/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html"]],
  ["v-64e4af5e","/computer-science/data-structure/03.%E4%B8%B2/",{"y":"p","t":"03.串"},["/computer-science/data-structure/03.串/","/computer-science/data-structure/03.%E4%B8%B2/index.html"]],
  ["v-ba481e42","/computer-science/data-structure/04.%E6%A0%91/",{"y":"p","t":"04.树"},["/computer-science/data-structure/04.树/","/computer-science/data-structure/04.%E6%A0%91/index.html"]],
  ["v-36036fae","/computer-science/data-structure/05.%E5%9B%BE/",{"y":"p","t":"05.图"},["/computer-science/data-structure/05.图/","/computer-science/data-structure/05.%E5%9B%BE/index.html"]],
  ["v-a9a116b2","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/",{"y":"p","t":"06.查找"},["/computer-science/data-structure/06.查找/","/computer-science/data-structure/06.%E6%9F%A5%E6%89%BE/index.html"]],
  ["v-2973d301","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/",{"y":"p","t":"07.排序"},["/computer-science/data-structure/07.排序/","/computer-science/data-structure/07.%E6%8E%92%E5%BA%8F/index.html"]],
  ["v-5bc93818","/category/",{"y":"p","t":"分类","I":0},["/category/index.html"]],
  ["v-744d024e","/tag/",{"y":"p","t":"标签","I":0},["/tag/index.html"]],
  ["v-e52c881c","/article/",{"y":"p","t":"文章","I":0},["/article/index.html"]],
  ["v-154dc4c4","/star/",{"y":"p","t":"收藏","I":0},["/star/index.html"]],
  ["v-01560935","/timeline/",{"y":"p","t":"时间轴","I":0},["/timeline/index.html"]],
  ["v-311ae7eb","/category/%E6%94%B6%E8%97%8F%E6%80%BB%E7%BB%93/",{"y":"p","t":"收藏总结 分类","I":0},["/category/收藏总结/","/category/%E6%94%B6%E8%97%8F%E6%80%BB%E7%BB%93/index.html"]],
  ["v-f02a46a8","/category/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{"y":"p","t":"算法及数据结构 分类","I":0},["/category/算法及数据结构/","/category/%E7%AE%97%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"]],
  ["v-4c40caa5","/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",{"y":"p","t":"操作系统 分类","I":0},["/category/操作系统/","/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"]],
  ["v-41590e77","/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{"y":"p","t":"设计模式 分类","I":0},["/category/设计模式/","/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"]],
  ["v-840864d0","/category/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%8A%E5%AE%89%E8%A3%85/",{"y":"p","t":"程序打包及安装 分类","I":0},["/category/程序打包及安装/","/category/%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%8A%E5%AE%89%E8%A3%85/index.html"]],
  ["v-1530f155","/category/%E6%B5%8B%E8%AF%95/",{"y":"p","t":"测试 分类","I":0},["/category/测试/","/category/%E6%B5%8B%E8%AF%95/index.html"]],
  ["v-6b6d7ad0","/category/web-%E6%9C%8D%E5%8A%A1%E5%99%A8/",{"y":"p","t":"WEB 服务器 分类","I":0},["/category/web-服务器/","/category/web-%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html"]],
  ["v-5e0b61bd","/category/%E6%95%B0%E6%8D%AE%E5%BA%93/",{"y":"p","t":"数据库 分类","I":0},["/category/数据库/","/category/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html"]],
  ["v-341ce816","/category/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91/",{"y":"p","t":"高性能高并发 分类","I":0},["/category/高性能高并发/","/category/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91/index.html"]],
  ["v-0929fcba","/category/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/",{"y":"p","t":"分布式原理 分类","I":0},["/category/分布式原理/","/category/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/index.html"]],
  ["v-0f843f03","/category/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/",{"y":"p","t":"数据分析 分类","I":0},["/category/数据分析/","/category/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/index.html"]],
  ["v-d50c56e0","/category/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/",{"y":"p","t":"数据存储 分类","I":0},["/category/数据存储/","/category/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/index.html"]],
  ["v-4bf82fae","/category/%E5%AE%B9%E5%99%A8%E5%8F%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/",{"y":"p","t":"容器及虚拟化技术 分类","I":0},["/category/容器及虚拟化技术/","/category/%E5%AE%B9%E5%99%A8%E5%8F%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/index.html"]],
  ["v-37a3dbea","/category/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/",{"y":"p","t":"消息中间件 分类","I":0},["/category/消息中间件/","/category/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/index.html"]],
  ["v-6b5d5c75","/category/%E7%A6%BB%E7%BA%BF%E6%89%B9%E5%A4%84%E7%90%86/",{"y":"p","t":"离线批处理 分类","I":0},["/category/离线批处理/","/category/%E7%A6%BB%E7%BA%BF%E6%89%B9%E5%A4%84%E7%90%86/index.html"]],
  ["v-69da83b2","/category/%E7%BB%BC%E5%90%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",{"y":"p","t":"综合解决方案 分类","I":0},["/category/综合解决方案/","/category/%E7%BB%BC%E5%90%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/index.html"]],
  ["v-006c22e5","/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/",{"y":"p","t":"微服务架构 分类","I":0},["/category/微服务架构/","/category/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/index.html"]],
  ["v-5cbf0c93","/category/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",{"y":"p","t":"机器视觉 分类","I":0},["/category/机器视觉/","/category/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/index.html"]],
  ["v-5e3b6d77","/category/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/",{"y":"p","t":"深度学习 分类","I":0},["/category/深度学习/","/category/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/index.html"]],
  ["v-7df0be8e","/category/%E9%87%91%E8%9E%8D%E6%9C%9F%E8%B4%A7/",{"y":"p","t":"金融期货 分类","I":0},["/category/金融期货/","/category/%E9%87%91%E8%9E%8D%E6%9C%9F%E8%B4%A7/index.html"]],
  ["v-0fc3efc1","/category/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6/",{"y":"p","t":"电动汽车 分类","I":0},["/category/电动汽车/","/category/%E7%94%B5%E5%8A%A8%E6%B1%BD%E8%BD%A6/index.html"]],
  ["v-5f1b2732","/category/%E5%9C%B0%E5%9B%BE%E5%8F%8Agps/",{"y":"p","t":"地图及GPS 分类","I":0},["/category/地图及gps/","/category/%E5%9C%B0%E5%9B%BE%E5%8F%8Agps/index.html"]],
  ["v-7849dbd0","/category/%E7%BB%BC%E5%90%88%E5%8F%8A%E5%AD%A6%E4%B9%A0/",{"y":"p","t":"综合及学习 分类","I":0},["/category/综合及学习/","/category/%E7%BB%BC%E5%90%88%E5%8F%8A%E5%AD%A6%E4%B9%A0/index.html"]],
  ["v-d7663088","/category/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/",{"y":"p","t":"工作总结 分类","I":0},["/category/工作总结/","/category/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/index.html"]],
  ["v-e90ef6c6","/category/%E5%AE%A2%E6%B5%81%E7%BB%9F%E8%AE%A1/",{"y":"p","t":"客流统计 分类","I":0},["/category/客流统计/","/category/%E5%AE%A2%E6%B5%81%E7%BB%9F%E8%AE%A1/index.html"]],
  ["v-756a27f8","/category/%E9%AB%98%E6%95%88%E8%83%BD%E5%8A%A0%E9%80%9F/",{"y":"p","t":"高效能加速 分类","I":0},["/category/高效能加速/","/category/%E9%AB%98%E6%95%88%E8%83%BD%E5%8A%A0%E9%80%9F/index.html"]],
  ["v-6d652280","/category/darknet/",{"y":"p","t":"Darknet 分类","I":0},["/category/darknet/index.html"]],
  ["v-586adb82","/category/ncnn/",{"y":"p","t":"NCNN 分类","I":0},["/category/ncnn/index.html"]],
  ["v-51250588","/category/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/",{"y":"p","t":"车牌识别 分类","I":0},["/category/车牌识别/","/category/%E8%BD%A6%E7%89%8C%E8%AF%86%E5%88%AB/index.html"]],
  ["v-57d4b7fd","/category/cnet/",{"y":"p","t":"CNET 分类","I":0},["/category/cnet/index.html"]],
  ["v-bc3d2b42","/category/%E6%99%BA%E6%85%A7%E9%BB%91%E6%9D%BF/",{"y":"p","t":"智慧黑板 分类","I":0},["/category/智慧黑板/","/category/%E6%99%BA%E6%85%A7%E9%BB%91%E6%9D%BF/index.html"]],
  ["v-29da37b8","/category/android/",{"y":"p","t":"Android 分类","I":0},["/category/android/index.html"]],
  ["v-5089bfcf","/category/%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7/",{"y":"p","t":"应用升级 分类","I":0},["/category/应用升级/","/category/%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7/index.html"]],
  ["v-9cbc5afe","/category/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/",{"y":"p","t":"手势识别 分类","I":0},["/category/手势识别/","/category/%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/index.html"]],
  ["v-5bf89d1e","/category/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/",{"y":"p","t":"图像处理 分类","I":0},["/category/图像处理/","/category/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/index.html"]],
  ["v-7ebab051","/category/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/",{"y":"p","t":"目标跟踪 分类","I":0},["/category/目标跟踪/","/category/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/index.html"]],
  ["v-9c48d85a","/category/linux/",{"y":"p","t":"Linux 分类","I":0},["/category/linux/index.html"]],
  ["v-39fcfa3a","/category/m5-mips/",{"y":"p","t":"M5-MIPS 分类","I":0},["/category/m5-mips/index.html"]],
  ["v-1234930f","/category/%E9%80%8F%E6%98%8E%E5%8A%A0%E5%AF%86/",{"y":"p","t":"透明加密 分类","I":0},["/category/透明加密/","/category/%E9%80%8F%E6%98%8E%E5%8A%A0%E5%AF%86/index.html"]],
  ["v-4b470bdb","/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/",{"y":"p","t":"计算机科学 分类","I":0},["/category/计算机科学/","/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.html"]],
  ["v-4f178b9c","/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",{"y":"p","t":"数据结构 分类","I":0},["/category/数据结构/","/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"]],
]
